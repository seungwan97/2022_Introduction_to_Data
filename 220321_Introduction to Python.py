#
#
#
x=10
#True/False
#""/"01"
#[]/[1,3]
#x>0,x>=10,x==10 (o) / x>11,x==20,x!=10 (x)

#if 조건식:
#    수행문1
#    수행문2
#    ...
#if의 기능 : if 조건식이 True일 때 한번 실행

#while 조건식:
#    수행문1
#    수행문2
#    ...
#while의 기능 : 조건식이 True일 때 반복 시행


number=0
while number!=4:
    print("text")
    number=int(input())
    break

#while문의 처음으로 돌아가기
#continue : 읽힐 시 그 아래 코드는 전부 스킵됨

a=0
while a<10:
    a=a+1
    if a % 2 == 1: # %:나눗셈 나머지 연산자 #바꿔말하면  n%2==0은 n의 배수라고 해석됨
        continue #밑으로 넘어갈건지 말건지를 결정하는 일종의 스위치 역할
    print(a)

while []:
    print("무한")
#조건식 안에 있는 것이 True이면 실행, False이면 실행하지 않는다.

coffee=1
money=300
while money:
    print("돈을 받았으니 커피를 준다")
    coffee=coffee-1
    print("남은 커피는 %d개 입니다." % coffee)
    if coffee==0:
        print("커피가 없다. 판매 중지")
        break


#파이썬 자료형
#문자형,숫자,리스트,bool

#튜플
#튜플은 리스트와 비슷하다.
#공통점:여러가지 요소를 가진다, 인덱싱과 슬라이싱이 가능하다, 덧셈곱셈연산이 가능하다(빼기나눗셈 등은 원래안됨), len함수 사용가능하다
#차이점:표기법에 차이가 있다, 값의 생성&삭제&수정여부가 다르다, 튜플은 1개의 요소를 가질 때는 뒤에 콤마가 들어간다
#튜플은 값을 바꿀 수 없다.
#값을 바꿀 수 없다는 것은 절대 바꾸면 안되는 코드(값)를 고정하는 것에 요긴히 사용된다.
listx=[]
listx=[1]
listx=[1,2,3]
listx=[1,2,'a']
listx=[1,2,['a']]
tp=() #빈 튜플
tp=(1,) #튜플은 1개의 요소여도 쉼표가 들어간다.
tp=(1,2,3,4)
tp=('a','b',('c','d')) #튜플 안에 튜플이 들어가있는 형태

#튜플은 요솟값이 한번 정해지면 지우거나 변경이 불가하다.

listx=[1,2,3]
print(listx[0])
del listx[0]
print(listx)

tp=(1,2,3)
#del tp[0] #값의 삭제가 불가하기에 오류가 남
#tp[0]=4 #값의 변경이 불가하기에 오류가 남

#튜플은 인덱싱이 가능하다.
print(tp[1])
tp=('a','b',('c','d'))
print(tp[2][0])
#튜플은 슬라이싱이 가능하다.
print(tp[0:2])
print(tp[:])
#튜플은 연산이 가능하다.
t1=(1,2,'a','b')
t2=(3,4)
print(t1+t2)
print(t2*3)
print(len(t1))


#딕셔너리
#대응관계를 나타내는 자료형
#ex) 이름="~~~"
#ex) 생일=111111"
#리스트나 튜플처럼 순차적으로 요솟값을 구하지 않고 Key를 통해 Value를 얻는다.
#딕셔너리의 기본구조 : 중괄호를 씀
#{Key1:Value1, Key2:Value2, Key3:Value3, ....}
#Key와 Value의 여러 쌍이 {}중괄호로 둘러싸여 있다.
#각각 요소는 Key:Value 형태로 이루어져 있다.
#쉼표로 구분된다.
#주의:Key에는 변하지 않는 값만을 사용, Value에는 변하지 않는 값과 변하는 값 모두 사용가능

dic={'name':'sw','phone':'01011112222'}
#dic의 Key는 2개 : name, phone
#dic의 Value는 두개 :  sw, 01011112222
a={1:'hi'} #키로 정수 지정, 밸류에 문자열 지정
a={'a':[1,2,3]} #키로 문자열 지정, 밸류에 리스트 지정

#딕셔너리 쌍 추가, 삭제
a={1:'a'}
a[2]='b' # a딕셔너리에 키가 2이고 밸류가 'b'인 한쌍 추가
print(a)
a['name']=1
print(a)
a[3]=[1,2,3]
print(a)
#a[[1,2,3]]='a' #리스트는 Key가 될 수 없음
#print(a)
#Key에는 문자, 숫자 가능
#Value에 문자, 숫자, 리스트 가능
del a[1] #여기서는 a가 딕셔너리이므로 인덱싱이 아니고 1번 Key값을 제거하라 라는 의미
print(a) #딕셔너리의 요소 (쌍) 삭제하기 : del a[key] => 해당 키와 밸류 한쌍이 삭제됨
seat={"이름1":10,"이름2":3}
#딕셔너리 검색 : Key값을 검색하여 Value를 얻는다
print(seat["이름2"])
print(seat["이름1"])
#리스트나 튜플, 문자열은 요소를 얻고자 할때 인덱싱 사용
#딕셔너리는 Key를 통해 구해야 함
# [   ] 안의 값이 인덕세 번호가 아닌 Key값

#딕셔너리 만들때 주의사항
#키값은 고유한 값
#중복된 Key가 설정되어 있으면 하나를 제외하고 모두 무시된다.
a={1:'a',1:'b'}
#Key가 중복되었을 때 1개를 제외한 나머지 Key는 무시된다. (맨 마지막 요소만 살아남는다.)
#따라서 키값은 고유한 값을 써야하는 것이다.
print(a)
a={(1,2):'p'}
print(a)
a={(1,1):'p',(1,2):'p',(1,3):'p',(1,4):'p',(2,1):'p',(2,2):'p',(2,3):'p',(2,4):'p'}
#딕셔너리의 Key에 리스트는 안되고 튜플은 된다 => 튜플형태를 좌표형태로 활용가능하다.(엑셀처럼)

#딕셔너리 전용(관련) 함수 : .을 찍고 사용한다.
a={(1,1):'p',(1,2):'p',(1,3):'p',(1,4):'p',(2,1):'p',(2,2):'p',(2,3):'p',(2,4):'p'}
#Key리스트 함수
print(a.keys()) #리스트 고유의 append,insert,pop,remove,sort 함수는 수행할 수 없다.
#Keys함수의 반환값은 딕셔너리 키 객체 형태이다.
lista=list(a.keys()) #딕셔너리 키 객체를 리스트 형태로 변환
print(lista[7]) #리스트에 인덱싱
#list() 나열된 데이터 형태를 리스트 자료형으로 변환하는 함수
#int() 숫자로 구성되어 있는 문자열 데이터를 실제 숫자로 변환
#str() 숫자를 문자로 변환 ex) 123->'123' #형 변환 함수

#Values 함수
print(a.values())
print(list(a.values()))

#Key, Value 쌍 얻기
print(a.items())
listi=list(a.items())
print(listi[2])

#쌍 지우기 함수 (clear)
#a.clear()
#print(a)

#Key로 Value 얻는 방법
print(a.get((1,1))) #같은 값이 나옴
print(a[(1,1)]) #같은 값이 나옴(그러나)
print(a.get((2,5))) # 없는 밸류를 얻고자 할대 오류 대신 None이 뜬다면
#print(a[(2,5)]) #get을 안썼을 때는 오류가 떠버림 따라서 get을 써야 한다.
#a[key] 방식으로 없는 키 값을 찾으면 Key에러가 발생해 프로그램이 종료됨
#a.get(key) 방식으로 없는 키 찾으면 None 반환하고 에러는 없음
print(a.get((2,5),"없음")) #None 대신 "없음"이라고 표시하고 싶을 때

a.get(2,3) in a
if (2,3) in a:
    print("2행 3열 존재")

print((2,8) in a) #해당 키가 딕셔너리 에 있는지 조사하는 방법 : in


"""
문제풀이
1.변수이름으로 사용 불가한 것 : 숫자로 시작하는 변수(ex)32,3x), 함수(sum), 예약어(if,while,for,break)
2.예약어 등 정해져있는 것은 소문자로 써야함 
3.함수는 반환값이 항상 존재하지는 않음 (있을수도 있고 없을수도 있다.)
4.변수의 값은 변경가능
5.whlie 중첩사용 가능, if 중첩사용 가능
"""


#반복문 for문
#while문과 비슷한 반복문

#for문의 기본구조
#for 변수 in 리스트(또는 튜플, 문자열):
#   수행문1
#   수행문2
#   ...

#리스트나 튜플이나 문자열의 첫 요소부터 끝 요소까지 차례대로 변수에 대입되어 한 바퀴씩 반복을 한다(끝 요소에 도달하는 시점까지)

test=['one','two','three']
for i in test:
    print(i)

a=[1,2,3,4,5,6,7,8,9]
x=0
#x외의 변수는 선언하지 않고 기존에 주어진 코드를 수정하지 않는다.
#a리스트에 10~15를 추가하고 프린트는 하지 않는다.
#a리스트에 15까지 전부 추가되면 한번만 a리스트 통째로 출력
while True :
    a.append(len(a)+1) #이 문제에서 len함수를 써주면 어떠한 상황에서도 맞는 값이 도출이 된다.
    if len(a)==15: #len(a)는 9이고 len(a)+1은 10이기 때문에 자동으로 1이 더해진 값이 추가가되고, 1en(a)+1이 15가되면~
        print(a) #~추가되지 않고 밑의 if문에 걸려 len(14)+1 값, 즉 a=[1,2,3,~14,15]가 프린트된다.
        break

a=[1,3,2,7] #쓰레기통
x=int(input("단위 무게")) #쓰레기의 무게
y=int(input("총 용량")) #쓰레기통의 용량
#리스트의 마지막 숫자부터 +5씩
#ex)마지막 숫자 5 => 10 15 20 25 30
#<=100까지 리스트에 요소 추가 후 출력
while True:
    if a[-1]<=y-x: #쓰레기를 넣을 용량인지를 체크하는 단계
        a.append(a[-1]+x) #넣을 수 있다고 판단이 될때
        continue #계속함(다시위로)
    else:
        print(a)
        break

a=[1,2,4,8,5,7,1,1,1,1]
x=5 #단위값
y=150 #용량
z=30
count=0
#리스트 a의 마지막 요소 바로 다음에는 30을 넣고 그 후로는 +5씩 추가한다
#<=150까지
while True:
    count = count+1
    if count==1: #첫바퀴에만 해당하는 if문
        a.append(z)
    if a[-1]<=y-x: #나머지바퀴 해당하는 if문 #y-x가 아닌 y라면 a.append에서 150이 넘어가는 값이 추가됨
        a.append(a[len(a)-1]+x) #따라서 이 식이 적절함
    else:
        print(a)
        break